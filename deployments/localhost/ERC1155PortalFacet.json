{
  "address": "0x6BE12696d3f34919a15472d11Fe59Bc6509042db",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "ERC1155",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "tokenIds",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "tokenAmounts",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "ERC1155BatchReceived",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "ERC1155",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address payable",
          "name": "receiver",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "tokenIds",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "ERC1155BatchWithdrawn",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "ERC1155",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "ERC1155Received",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "ERC1155",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address payable",
          "name": "receiver",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "ERC1155Withdrawn",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "erc1155BatchWithdrawal",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "erc1155Withdrawal",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_operator",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_from",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "_tokenIds",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "_tokenAmounts",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "onERC1155BatchReceived",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_operator",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_from",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_tokenAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "onERC1155Received",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xc0b20745fc1ed8c04719a2ce9d9b5e96626b1c12d26ce1f19394d4a5788f4efe",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "956725",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xcf2b1a186ceed13370311edbdfbf285f2656d0e9e8c015593cb2aa60302aeeb8",
    "transactionHash": "0xc0b20745fc1ed8c04719a2ce9d9b5e96626b1c12d26ce1f19394d4a5788f4efe",
    "logs": [],
    "blockNumber": 21,
    "cumulativeGasUsed": "956725",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "dddd641f7a3f4461e4ff41e8a19645a9",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ERC1155\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC1155BatchReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ERC1155\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC1155BatchWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ERC1155\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC1155Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ERC1155\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC1155Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"erc1155BatchWithdrawal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"erc1155Withdrawal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"erc1155BatchWithdrawal(bytes)\":{\"details\":\"can only be called by the Rollups contract\",\"params\":{\"_data\":\"data with withdrawal information\"}},\"erc1155Withdrawal(bytes)\":{\"details\":\"can only be called by the Rollups contract\",\"params\":{\"_data\":\"data with withdrawal information\"}},\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\":{\"details\":\"The ERC1155 smart contract calls this function on the recipient  after a `transfer`. This function MAY throw to revert and reject the  transfer. Return of other than the magic value MUST result in the  transaction being reverted.  Note: the contract address is always the message sender.\",\"params\":{\"_data\":\"Additional data to be interpreted by L2\",\"_from\":\"The address which previously owned the tokens\",\"_operator\":\"The address which called `safeBatchTransferFrom` function\",\"_tokenAmounts\":\"The token amounts which are being transferred\",\"_tokenIds\":\"The token identifiers which are being transferred\"},\"returns\":{\"_0\":\"this function selector unless throwing\"}},\"onERC1155Received(address,address,uint256,uint256,bytes)\":{\"details\":\"The ERC1155 smart contract calls this function on the recipient  after a `transfer`. This function MAY throw to revert and reject the  transfer. Return of other than the magic value MUST result in the  transaction being reverted.  Note: the contract address is always the message sender.\",\"params\":{\"_data\":\"Additional data to be interpreted by L2\",\"_from\":\"The address which previously owned the token\",\"_operator\":\"The address which called `safeTransferFrom` function\",\"_tokenAmount\":\"The token amount which is being transferred\",\"_tokenId\":\"The token identifier which is being transferred\"},\"returns\":{\"_0\":\"this function selector unless throwing\"}}},\"version\":1},\"userdoc\":{\"events\":{\"ERC1155BatchReceived(address,address,address,uint256[],uint256[],bytes)\":{\"notice\":\"emitted on a call to `onERC1155BatchReceived`\"},\"ERC1155BatchWithdrawn(address,address,uint256[],uint256[],bytes)\":{\"notice\":\"emitted on ERC1155 batch withdrawal\"},\"ERC1155Received(address,address,address,uint256,uint256,bytes)\":{\"notice\":\"emitted on a call to `onERC1155Received`\"},\"ERC1155Withdrawn(address,address,uint256,uint256,bytes)\":{\"notice\":\"emitted on ERC1155 withdrawal\"}},\"kind\":\"user\",\"methods\":{\"erc1155BatchWithdrawal(bytes)\":{\"notice\":\"withdraw a batch of ERC1155 tokens from the portal\"},\"erc1155Withdrawal(bytes)\":{\"notice\":\"withdraw an ERC1155 token from the portal\"},\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\":{\"notice\":\"Handle the receipt of a batch of ERC1155 tokens\"},\"onERC1155Received(address,address,uint256,uint256,bytes)\":{\"notice\":\"Handle the receipt of an ERC1155 token\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/ERC1155PortalFacet.sol\":\"ERC1155PortalFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x6392f2cfe3a5ee802227fe7a2dfd47096d881aec89bddd214b35c5b46d3cd941\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/IBank.sol\":{\"content\":\"// Copyright 2022 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n// @title Bank interface\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IBank {\\n    /// @notice returns the token used internally\\n    function getToken() external view returns (IERC20);\\n\\n    /// @notice get balance of `_owner`\\n    /// @param _owner account owner\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /// @notice transfer `_value` tokens from bank to `_to`\\n    /// @notice decrease the balance of caller by `_value`\\n    /// @param _to account that will receive `_value` tokens\\n    /// @param _value amount of tokens to be transfered\\n    function transferTokens(address _to, uint256 _value) external;\\n\\n    /// @notice transfer `_value` tokens from caller to bank\\n    /// @notice increase the balance of `_to` by `_value`\\n    /// @dev you may need to call `token.approve(bank, _value)`\\n    /// @param _to account that will have their balance increased by `_value`\\n    /// @param _value amount of tokens to be transfered\\n    function depositTokens(address _to, uint256 _value) external;\\n\\n    /// @notice `value` tokens were transfered from the bank to `to`\\n    /// @notice the balance of `from` was decreased by `value`\\n    /// @dev is triggered on any successful call to `transferTokens`\\n    /// @param from the account/contract that called `transferTokens` and\\n    ///              got their balance decreased by `value`\\n    /// @param to the one that received `value` tokens from the bank\\n    /// @param value amount of tokens that were transfered\\n    event Transfer(address indexed from, address to, uint256 value);\\n\\n    /// @notice `value` tokens were transfered from `from` to bank\\n    /// @notice the balance of `to` was increased by `value`\\n    /// @dev is triggered on any successful call to `depositTokens`\\n    /// @param from the account/contract that called `depositTokens` and\\n    ///              transfered `value` tokens to the bank\\n    /// @param to the one that got their balance increased by `value`\\n    /// @param value amount of tokens that were transfered\\n    event Deposit(address from, address indexed to, uint256 value);\\n}\\n\",\"keccak256\":\"0x483dc9b0c26e3a5d43148cf847bd4df2af03438a0d76d60d33549de3ca2dd77d\",\"license\":\"Apache-2.0\"},\"contracts/facets/ERC1155PortalFacet.sol\":{\"content\":\"// Copyright 2022 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Generic ERC1155 Portal facet\\npragma solidity ^0.8.0;\\n\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\nimport {IERC1155Portal} from \\\"../interfaces/IERC1155Portal.sol\\\";\\n\\nimport {LibInput} from \\\"../libraries/LibInput.sol\\\";\\n\\ncontract ERC1155PortalFacet is IERC1155Portal {\\n    using LibInput for LibInput.DiamondStorage;\\n\\n    bytes32 constant INPUT_HEADER = keccak256(\\\"ERC1155_Transfer\\\");\\n\\n    /// @notice Handle the receipt of an ERC1155 token\\n    /// @dev The ERC1155 smart contract calls this function on the recipient\\n    ///  after a `transfer`. This function MAY throw to revert and reject the\\n    ///  transfer. Return of other than the magic value MUST result in the\\n    ///  transaction being reverted.\\n    ///  Note: the contract address is always the message sender.\\n    /// @param _operator The address which called `safeTransferFrom` function\\n    /// @param _from The address which previously owned the token\\n    /// @param _tokenId The token identifier which is being transferred\\n    /// @param _tokenAmount The token amount which is being transferred\\n    /// @param _data Additional data to be interpreted by L2\\n    /// @return this function selector unless throwing\\n    function onERC1155Received(\\n        address _operator,\\n        address _from,\\n        uint256 _tokenId,\\n        uint256 _tokenAmount,\\n        bytes calldata _data\\n    ) public override returns (bytes4) {\\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\\n        address erc1155Contract = msg.sender;\\n\\n        bytes memory input = abi.encode(\\n            INPUT_HEADER,\\n            erc1155Contract,\\n            _operator,\\n            _from,\\n            _tokenId,\\n            _tokenAmount,\\n            _data\\n        );\\n\\n        inputDS.addInternalInput(input);\\n\\n        emit ERC1155Received(\\n            erc1155Contract,\\n            _operator,\\n            _from,\\n            _tokenId,\\n            _tokenAmount,\\n            _data\\n        );\\n\\n        // return the magic value to approve the transfer\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    /// @notice Handle the receipt of a batch of ERC1155 tokens\\n    /// @dev The ERC1155 smart contract calls this function on the recipient\\n    ///  after a `transfer`. This function MAY throw to revert and reject the\\n    ///  transfer. Return of other than the magic value MUST result in the\\n    ///  transaction being reverted.\\n    ///  Note: the contract address is always the message sender.\\n    /// @param _operator The address which called `safeBatchTransferFrom` function\\n    /// @param _from The address which previously owned the tokens\\n    /// @param _tokenIds The token identifiers which are being transferred\\n    /// @param _tokenAmounts The token amounts which are being transferred\\n    /// @param _data Additional data to be interpreted by L2\\n    /// @return this function selector unless throwing\\n    function onERC1155BatchReceived(\\n        address _operator,\\n        address _from,\\n        uint256[] calldata _tokenIds,\\n        uint256[] calldata _tokenAmounts,\\n        bytes calldata _data\\n    ) public override returns (bytes4) {\\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\\n        address erc1155Contract = msg.sender;\\n\\n        bytes memory input = abi.encode(\\n            INPUT_HEADER,\\n            erc1155Contract,\\n            _operator,\\n            _from,\\n            _tokenIds,\\n            _tokenAmounts,\\n            _data\\n        );\\n\\n        inputDS.addInternalInput(input);\\n\\n        emit ERC1155BatchReceived(\\n            erc1155Contract,\\n            _operator,\\n            _from,\\n            _tokenIds,\\n            _tokenAmounts,\\n            _data\\n        );\\n\\n        // return the magic value to approve the transfer\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n\\n    /// @notice withdraw an ERC1155 token from the portal\\n    /// @param _data data with withdrawal information\\n    /// @dev can only be called by the Rollups contract\\n    function erc1155Withdrawal(bytes calldata _data)\\n        public\\n        override\\n        returns (bool)\\n    {\\n        // Delegate calls preserve msg.sender, msg.value and address(this)\\n        require(msg.sender == address(this), \\\"only itself\\\");\\n\\n        (\\n            address tokenAddr,\\n            address payable receiver,\\n            uint256 tokenId,\\n            uint256 tokenAmount,\\n            bytes memory transferData\\n        ) = abi.decode(_data, (address, address, uint256, uint256, bytes));\\n\\n        IERC1155 token = IERC1155(tokenAddr);\\n\\n        // transfer reverts on failure\\n        token.safeTransferFrom(\\n            address(this),\\n            receiver,\\n            tokenId,\\n            tokenAmount,\\n            transferData\\n        );\\n\\n        emit ERC1155Withdrawn(\\n            tokenAddr,\\n            receiver,\\n            tokenId,\\n            tokenAmount,\\n            transferData\\n        );\\n        return true;\\n    }\\n\\n    /// @notice withdraw a batch of ERC1155 tokens from the portal\\n    /// @param _data data with withdrawal information\\n    /// @dev can only be called by the Rollups contract\\n    function erc1155BatchWithdrawal(bytes calldata _data)\\n        public\\n        override\\n        returns (bool)\\n    {\\n        // Delegate calls preserve msg.sender, msg.value and address(this)\\n        require(msg.sender == address(this), \\\"only itself\\\");\\n\\n        (\\n            address tokenAddr,\\n            address payable receiver,\\n            uint256[] memory tokenIds,\\n            uint256[] memory tokenAmounts,\\n            bytes memory transferData\\n        ) = abi.decode(_data, (address, address, uint256[], uint256[], bytes));\\n\\n        IERC1155 token = IERC1155(tokenAddr);\\n\\n        // transfer reverts on failure\\n        token.safeBatchTransferFrom(\\n            address(this),\\n            receiver,\\n            tokenIds,\\n            tokenAmounts,\\n            transferData\\n        );\\n\\n        emit ERC1155BatchWithdrawn(\\n            tokenAddr,\\n            receiver,\\n            tokenIds,\\n            tokenAmounts,\\n            transferData\\n        );\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0xf901292141b415df73eb59d64e65dcb6fededd957379d3d501f05acd64493c86\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/IERC1155Portal.sol\":{\"content\":\"// Copyright 2022 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Generic ERC1155 Portal interface\\npragma solidity >=0.7.0;\\n\\nimport {IERC1155Receiver} from \\\"./IERC1155Receiver.sol\\\";\\n\\ninterface IERC1155Portal is IERC1155Receiver {\\n    /// @notice withdraw an ERC1155 token from the portal\\n    /// @param _data data with withdrawal information\\n    /// @dev can only be called by the Rollups contract\\n    function erc1155Withdrawal(bytes calldata _data) external returns (bool);\\n\\n    /// @notice withdraw a batch of ERC1155 tokens from the portal\\n    /// @param _data data with withdrawal information\\n    /// @dev can only be called by the Rollups contract\\n    function erc1155BatchWithdrawal(bytes calldata _data)\\n        external\\n        returns (bool);\\n\\n    /// @notice emitted on a call to `onERC1155Received`\\n    event ERC1155Received(\\n        address ERC1155,\\n        address operator,\\n        address sender,\\n        uint256 tokenId,\\n        uint256 tokenAmount,\\n        bytes data\\n    );\\n\\n    /// @notice emitted on a call to `onERC1155BatchReceived`\\n    event ERC1155BatchReceived(\\n        address ERC1155,\\n        address operator,\\n        address sender,\\n        uint256[] tokenIds,\\n        uint256[] tokenAmounts,\\n        bytes data\\n    );\\n\\n    /// @notice emitted on ERC1155 withdrawal\\n    event ERC1155Withdrawn(\\n        address ERC1155,\\n        address payable receiver,\\n        uint256 tokenId,\\n        uint256 amount,\\n        bytes data\\n    );\\n\\n    /// @notice emitted on ERC1155 batch withdrawal\\n    event ERC1155BatchWithdrawn(\\n        address ERC1155,\\n        address payable receiver,\\n        uint256[] tokenIds,\\n        uint256[] amounts,\\n        bytes data\\n    );\\n}\\n\",\"keccak256\":\"0x77fe973c54c706d3c24d594af205efb8efd9a78fc25c9b3e344370e689ecc2d5\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/IERC1155Receiver.sol\":{\"content\":\"// IERC1155Receiver.sol imported from OpenZeppelin modified to not inherit from\\n// IERC165 (conflicts with the Diamond implementation)\\n//\\n// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xe4c9bfb8cfbab15eeaaf114dc9bba370346c1eda4a516abadf046846dd1d3c5f\",\"license\":\"MIT\"},\"contracts/interfaces/IRollups.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Rollups interface\\npragma solidity >=0.7.0;\\n\\n// InputAccumulation - Inputs being accumulated for currrent epoch\\n// AwaitingConsensus - No disagreeing claims (or no claims)\\n// AwaitingDispute - Waiting for dispute to be over\\n// inputs received during InputAccumulation will be included in the\\n// current epoch. Inputs received while WaitingClaims or ChallengesInProgress\\n// are accumulated for the next epoch\\nenum Phase {\\n    InputAccumulation,\\n    AwaitingConsensus,\\n    AwaitingDispute\\n}\\n\\ninterface IRollups {\\n    /// @notice claim the result of current epoch\\n    /// @param _epochHash hash of epoch\\n    /// @dev ValidatorManager makes sure that msg.sender is allowed\\n    ///      and that claim != bytes32(0)\\n    /// TODO: add signatures for aggregated claims\\n    function claim(bytes32 _epochHash) external;\\n\\n    /// @notice finalize epoch after timeout\\n    /// @dev can only be called if challenge period is over\\n    function finalizeEpoch() external;\\n\\n    /// @notice returns index of current (accumulating) epoch\\n    /// @return index of current epoch\\n    /// @dev if phase is input accumulation, then the epoch number is length\\n    ///      of finalized epochs array, else there are two epochs two non\\n    ///      finalized epochs, one awaiting consensus/dispute and another\\n    ///      accumulating input\\n    function getCurrentEpoch() external view returns (uint256);\\n\\n    /// @notice claim submitted\\n    /// @param epochHash claim being submitted by this epoch\\n    /// @param claimer address of current claimer\\n    /// @param epochNumber number of the epoch being submitted\\n    event Claim(\\n        uint256 indexed epochNumber,\\n        address claimer,\\n        bytes32 epochHash\\n    );\\n\\n    /// @notice epoch finalized\\n    /// @param epochNumber number of the epoch being finalized\\n    /// @param epochHash claim being submitted by this epoch\\n    event FinalizeEpoch(uint256 indexed epochNumber, bytes32 epochHash);\\n\\n    /// @notice dispute resolved\\n    /// @param winner winner of dispute\\n    /// @param loser loser of dispute\\n    /// @param winningClaim initial claim of winning validator\\n    event ResolveDispute(address winner, address loser, bytes32 winningClaim);\\n\\n    /// @notice phase change\\n    /// @param newPhase new phase\\n    event PhaseChange(Phase newPhase);\\n}\\n\",\"keccak256\":\"0x241c3ee8bb900067903ac836d5f3ee81eca587c7f225ad6df686478a6b27329b\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/IValidatorManager.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Validator Manager interface\\npragma solidity >=0.7.0;\\n\\n// NoConflict - No conflicting claims or consensus\\n// Consensus - All validators had equal claims\\n// Conflict - Claim is conflicting with previous one\\nenum Result {\\n    NoConflict,\\n    Consensus,\\n    Conflict\\n}\\n\\n// TODO: What is the incentive for validators to not just copy the first claim that arrived?\\ninterface IValidatorManager {\\n    /// @notice get current claim\\n    function getCurrentClaim() external view returns (bytes32);\\n\\n    /// @notice emitted on Claim received\\n    event ClaimReceived(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on Dispute end\\n    event DisputeEnded(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on new Epoch\\n    event NewEpoch(bytes32 claim);\\n}\\n\",\"keccak256\":\"0x7eccbaf15dc80cd402459e8c940b0012fd3d3b8d2882fa13798afe92a9ea3b86\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibClaimsMask.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title ClaimsMask library\\npragma solidity >=0.8.8;\\n\\n// ClaimsMask is used to keep track of the number of claims for up to 8 validators\\n// | agreement mask | consensus goal mask | #claims_validator7 | #claims_validator6 | ... | #claims_validator0 |\\n// |     8 bits     |        8 bits       |      30 bits       |      30 bits       | ... |      30 bits       |\\n// In Validator Manager, #claims_validator indicates the #claims the validator has made.\\n// In Fee Manager, #claims_validator indicates the #claims the validator has redeemed. In this case,\\n//      agreement mask and consensus goal mask are not used.\\n\\ntype ClaimsMask is uint256;\\n\\nlibrary LibClaimsMask {\\n    uint256 constant claimsBitLen = 30; // #bits used for each #claims\\n\\n    /// @notice this function creates a new ClaimsMask variable with value _value\\n    /// @param  _value the value following the format of ClaimsMask\\n    function newClaimsMask(uint256 _value) internal pure returns (ClaimsMask) {\\n        return ClaimsMask.wrap(_value);\\n    }\\n\\n    /// @notice this function creates a new ClaimsMask variable with the consensus goal mask set,\\n    ///         according to the number of validators\\n    /// @param  _numValidators the number of validators\\n    function newClaimsMaskWithConsensusGoalSet(\\n        uint256 _numValidators\\n    ) internal pure returns (ClaimsMask) {\\n        require(_numValidators <= 8, \\\"up to 8 validators\\\");\\n        uint256 consensusMask = (1 << _numValidators) - 1;\\n        return ClaimsMask.wrap(consensusMask << 240); // 256 - 8 - 8 = 240\\n    }\\n\\n    /// @notice this function returns the #claims for the specified validator\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    ///     this index can be obtained though `getNumberOfClaimsByIndex` function in Validator Manager\\n    function getNumClaims(\\n        ClaimsMask _claimsMask,\\n        uint256 _validatorIndex\\n    ) internal pure returns (uint256) {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        uint256 bitmask = (1 << claimsBitLen) - 1;\\n        return\\n            (ClaimsMask.unwrap(_claimsMask) >>\\n                (claimsBitLen * _validatorIndex)) & bitmask;\\n    }\\n\\n    /// @notice this function increases the #claims for the specified validator\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    /// @param  _value the increase amount\\n    function increaseNumClaims(\\n        ClaimsMask _claimsMask,\\n        uint256 _validatorIndex,\\n        uint256 _value\\n    ) internal pure returns (ClaimsMask) {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        uint256 currentNum = getNumClaims(_claimsMask, _validatorIndex);\\n        uint256 newNum = currentNum + _value; // overflows checked by default with sol0.8\\n        return setNumClaims(_claimsMask, _validatorIndex, newNum);\\n    }\\n\\n    /// @notice this function sets the #claims for the specified validator\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    /// @param  _value the set value\\n    function setNumClaims(\\n        ClaimsMask _claimsMask,\\n        uint256 _validatorIndex,\\n        uint256 _value\\n    ) internal pure returns (ClaimsMask) {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        require(_value <= ((1 << claimsBitLen) - 1), \\\"ClaimsMask Overflow\\\");\\n        uint256 bitmask = ~(((1 << claimsBitLen) - 1) <<\\n            (claimsBitLen * _validatorIndex));\\n        uint256 clearedClaimsMask = ClaimsMask.unwrap(_claimsMask) & bitmask;\\n        _claimsMask = ClaimsMask.wrap(\\n            clearedClaimsMask | (_value << (claimsBitLen * _validatorIndex))\\n        );\\n        return _claimsMask;\\n    }\\n\\n    /// @notice get consensus goal mask\\n    /// @param  _claimsMask the ClaimsMask value\\n    function clearAgreementMask(\\n        ClaimsMask _claimsMask\\n    ) internal pure returns (ClaimsMask) {\\n        uint256 clearedMask = ClaimsMask.unwrap(_claimsMask) & ((1 << 248) - 1); // 256 - 8 = 248\\n        return ClaimsMask.wrap(clearedMask);\\n    }\\n\\n    /// @notice get the entire agreement mask\\n    /// @param  _claimsMask the ClaimsMask value\\n    function getAgreementMask(\\n        ClaimsMask _claimsMask\\n    ) internal pure returns (uint256) {\\n        return (ClaimsMask.unwrap(_claimsMask) >> 248); // get the first 8 bits\\n    }\\n\\n    /// @notice check if a validator has already claimed\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    function alreadyClaimed(\\n        ClaimsMask _claimsMask,\\n        uint256 _validatorIndex\\n    ) internal pure returns (bool) {\\n        // get the first 8 bits. Then & operation on the validator's bit to see if it's set\\n        return\\n            (((ClaimsMask.unwrap(_claimsMask) >> 248) >> _validatorIndex) &\\n                1) != 0;\\n    }\\n\\n    /// @notice set agreement mask for the specified validator\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    function setAgreementMask(\\n        ClaimsMask _claimsMask,\\n        uint256 _validatorIndex\\n    ) internal pure returns (ClaimsMask) {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        uint256 setMask = (ClaimsMask.unwrap(_claimsMask) |\\n            (1 << (248 + _validatorIndex))); // 256 - 8 = 248\\n        return ClaimsMask.wrap(setMask);\\n    }\\n\\n    /// @notice get the entire consensus goal mask\\n    /// @param  _claimsMask the ClaimsMask value\\n    function getConsensusGoalMask(\\n        ClaimsMask _claimsMask\\n    ) internal pure returns (uint256) {\\n        return ((ClaimsMask.unwrap(_claimsMask) << 8) >> 248); // get the second 8 bits\\n    }\\n\\n    /// @notice remove validator from the ClaimsMask\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    function removeValidator(\\n        ClaimsMask _claimsMask,\\n        uint256 _validatorIndex\\n    ) internal pure returns (ClaimsMask) {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        uint256 claimsMaskValue = ClaimsMask.unwrap(_claimsMask);\\n        // remove validator from agreement bitmask\\n        uint256 zeroMask = ~(1 << (_validatorIndex + 248)); // 256 - 8 = 248\\n        claimsMaskValue = (claimsMaskValue & zeroMask);\\n        // remove validator from consensus goal mask\\n        zeroMask = ~(1 << (_validatorIndex + 240)); // 256 - 8 - 8 = 240\\n        claimsMaskValue = (claimsMaskValue & zeroMask);\\n        // remove validator from #claims\\n        return\\n            setNumClaims(ClaimsMask.wrap(claimsMaskValue), _validatorIndex, 0);\\n    }\\n}\\n\",\"keccak256\":\"0x217eb2438f591832d5c61aaf7102c1dbc1feed4ddb871728fc98975ded0e72f2\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibDisputeManager.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Dispute Manager library\\npragma solidity ^0.8.0;\\n\\nimport {LibRollups} from \\\"../libraries/LibRollups.sol\\\";\\n\\nlibrary LibDisputeManager {\\n    using LibRollups for LibRollups.DiamondStorage;\\n\\n    /// @notice initiates a dispute betweent two players\\n    /// @param claims conflicting claims\\n    /// @param claimers addresses of senders of conflicting claim\\n    /// @dev this is a mock implementation that just gives the win\\n    ///      to the address in the first posititon of claimers array\\n    function initiateDispute(\\n        bytes32[2] memory claims,\\n        address payable[2] memory claimers\\n    ) internal {\\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\\n            .diamondStorage();\\n        rollupsDS.resolveDispute(claimers[0], claimers[1], claims[0]);\\n    }\\n}\\n\",\"keccak256\":\"0x7d3fdb94a17c7f61ef8f6431f42eaa307b30398e3c24093c0526f449752563c9\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibFeeManager.sol\":{\"content\":\"// Copyright 2022 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Fee Manager library\\npragma solidity ^0.8.0;\\n\\nimport {LibValidatorManager} from \\\"../libraries/LibValidatorManager.sol\\\";\\nimport {LibClaimsMask, ClaimsMask} from \\\"../libraries/LibClaimsMask.sol\\\";\\nimport {IBank} from \\\"../IBank.sol\\\";\\n\\nlibrary LibFeeManager {\\n    using LibValidatorManager for LibValidatorManager.DiamondStorage;\\n    using LibFeeManager for LibFeeManager.DiamondStorage;\\n    using LibClaimsMask for ClaimsMask;\\n\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"FeeManager.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        address owner; // owner of Fee Manager\\n        uint256 feePerClaim;\\n        IBank bank; // bank that holds the tokens to pay validators\\n        bool lock; // reentrancy lock\\n        // A bit set used for up to 8 validators.\\n        // The first 16 bits are not used to keep compatibility with the validator manager contract.\\n        // The following every 30 bits are used to indicate the number of total claims each validator has made\\n        // |     not used    | #claims_validator7 | #claims_validator6 | ... | #claims_validator0 |\\n        // |     16 bits     |      30 bits       |      30 bits       | ... |      30 bits       |\\n        ClaimsMask numClaimsRedeemed;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function onlyOwner(DiamondStorage storage ds) internal view {\\n        require(ds.owner == msg.sender, \\\"caller is not the owner\\\");\\n    }\\n\\n    /// @notice this function can be called to check the number of claims that's redeemable for the validator\\n    /// @param  ds pointer to FeeManager's diamond storage\\n    /// @param  _validator address of the validator\\n    function numClaimsRedeemable(\\n        DiamondStorage storage ds,\\n        address _validator\\n    ) internal view returns (uint256) {\\n        require(_validator != address(0), \\\"address should not be 0\\\");\\n\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n        uint256 valIndex = validatorManagerDS.getValidatorIndex(_validator); // will revert if not found\\n        uint256 totalClaims = validatorManagerDS.claimsMask.getNumClaims(\\n            valIndex\\n        );\\n        uint256 redeemedClaims = ds.numClaimsRedeemed.getNumClaims(valIndex);\\n\\n        // underflow checked by default with sol0.8\\n        // which means if the validator is removed, calling this function will\\n        // either return 0 or revert\\n        return totalClaims - redeemedClaims;\\n    }\\n\\n    /// @notice this function can be called to check the number of claims that has been redeemed for the validator\\n    /// @param  ds pointer to FeeManager's diamond storage\\n    /// @param  _validator address of the validator\\n    function getNumClaimsRedeemed(\\n        DiamondStorage storage ds,\\n        address _validator\\n    ) internal view returns (uint256) {\\n        require(_validator != address(0), \\\"address should not be 0\\\");\\n\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n        uint256 valIndex = validatorManagerDS.getValidatorIndex(_validator); // will revert if not found\\n        uint256 redeemedClaims = ds.numClaimsRedeemed.getNumClaims(valIndex);\\n\\n        return redeemedClaims;\\n    }\\n\\n    /// @notice contract owner can reset the value of fee per claim\\n    /// @param  ds pointer to FeeManager's diamond storage\\n    /// @param  _value the new value of fee per claim\\n    function resetFeePerClaim(\\n        DiamondStorage storage ds,\\n        uint256 _value\\n    ) internal {\\n        // before resetting the feePerClaim, pay fees for all validators as per current rates\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n        for (\\n            uint256 valIndex;\\n            valIndex < validatorManagerDS.maxNumValidators;\\n            valIndex++\\n        ) {\\n            address validator = validatorManagerDS.validators[valIndex];\\n            if (validator != address(0)) {\\n                uint256 nowRedeemingClaims = ds.numClaimsRedeemable(validator);\\n                if (nowRedeemingClaims > 0) {\\n                    ds.numClaimsRedeemed = ds\\n                        .numClaimsRedeemed\\n                        .increaseNumClaims(valIndex, nowRedeemingClaims);\\n\\n                    uint256 feesToSend = nowRedeemingClaims * ds.feePerClaim; // number of erc20 tokens to send\\n                    ds.bank.transferTokens(validator, feesToSend); // will revert if transfer fails\\n                    // emit the number of claimed being redeemed, instead of the amount of tokens\\n                    emit FeeRedeemed(validator, nowRedeemingClaims);\\n                }\\n            }\\n        }\\n        ds.feePerClaim = _value;\\n        emit FeePerClaimReset(_value);\\n    }\\n\\n    /// @notice this function can be called to redeem fees for validators\\n    /// @param  ds pointer to FeeManager's diamond storage\\n    /// @param  _validator address of the validator that is redeeming\\n    function redeemFee(DiamondStorage storage ds, address _validator) internal {\\n        // follow the Checks-Effects-Interactions pattern for security\\n\\n        // ** checks **\\n        uint256 nowRedeemingClaims = ds.numClaimsRedeemable(_validator);\\n        require(nowRedeemingClaims > 0, \\\"nothing to redeem yet\\\");\\n\\n        // ** effects **\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n        uint256 valIndex = validatorManagerDS.getValidatorIndex(_validator); // will revert if not found\\n        ds.numClaimsRedeemed = ds.numClaimsRedeemed.increaseNumClaims(\\n            valIndex,\\n            nowRedeemingClaims\\n        );\\n\\n        // ** interactions **\\n        uint256 feesToSend = nowRedeemingClaims * ds.feePerClaim; // number of erc20 tokens to send\\n        ds.bank.transferTokens(_validator, feesToSend); // will revert if transfer fails\\n        // emit the number of claimed being redeemed, instead of the amount of tokens\\n        emit FeeRedeemed(_validator, nowRedeemingClaims);\\n    }\\n\\n    /// @notice removes a validator\\n    /// @param ds diamond storage pointer\\n    /// @param index index of validator to be removed\\n    function removeValidator(\\n        DiamondStorage storage ds,\\n        uint256 index\\n    ) internal {\\n        ds.numClaimsRedeemed = ds.numClaimsRedeemed.setNumClaims(index, 0);\\n    }\\n\\n    /// @notice emitted on resetting feePerClaim\\n    event FeePerClaimReset(uint256 value);\\n\\n    /// @notice emitted on ERC20 funds redeemed by validator\\n    event FeeRedeemed(address validator, uint256 claims);\\n}\\n\",\"keccak256\":\"0x00f83789adb64fe2b18a7fa96c9f3e73043226bd8b3ec6887349ae4021d8e6ca\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibInput.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Input library\\npragma solidity ^0.8.0;\\n\\nimport {LibRollups} from \\\"../libraries/LibRollups.sol\\\";\\n\\nlibrary LibInput {\\n    using LibRollups for LibRollups.DiamondStorage;\\n\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"Input.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        // always needs to keep track of two input boxes:\\n        // 1 for the input accumulation of next epoch\\n        // and 1 for the messages during current epoch. To save gas we alternate\\n        // between inputBox0 and inputBox1\\n        bytes32[] inputBox0;\\n        bytes32[] inputBox1;\\n        uint256 inputDriveSize; // size of input flashdrive\\n        uint256 currentInputBox;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /// @notice get input inside inbox of currently proposed claim\\n    /// @param ds diamond storage pointer\\n    /// @param index index of input inside that inbox\\n    /// @return hash of input at index index\\n    /// @dev currentInputBox being zero means that the inputs for\\n    ///      the claimed epoch are on input box one\\n    function getInput(\\n        DiamondStorage storage ds,\\n        uint256 index\\n    ) internal view returns (bytes32) {\\n        return\\n            ds.currentInputBox == 0 ? ds.inputBox1[index] : ds.inputBox0[index];\\n    }\\n\\n    /// @notice get number of inputs inside inbox of currently proposed claim\\n    /// @param ds diamond storage pointer\\n    /// @return number of inputs on that input box\\n    /// @dev currentInputBox being zero means that the inputs for\\n    ///      the claimed epoch are on input box one\\n    function getNumberOfInputs(\\n        DiamondStorage storage ds\\n    ) internal view returns (uint256) {\\n        return\\n            ds.currentInputBox == 0 ? ds.inputBox1.length : ds.inputBox0.length;\\n    }\\n\\n    /// @notice add input to processed by next epoch\\n    /// @param ds diamond storage pointer\\n    /// @param input input to be understood by offchain machine\\n    /// @dev offchain code is responsible for making sure\\n    ///      that input size is power of 2 and multiple of 8 since\\n    ///      the offchain machine has a 8 byte word\\n    function addInput(\\n        DiamondStorage storage ds,\\n        bytes memory input\\n    ) internal returns (bytes32) {\\n        return addInputFromSender(ds, input, msg.sender);\\n    }\\n\\n    /// @notice add internal input to processed by next epoch\\n    /// @notice this function is to be reserved for internal usage only\\n    /// @notice for normal inputs, call `addInput` instead\\n    /// @param ds diamond storage pointer\\n    /// @param input input to be understood by offchain machine\\n    /// @dev offchain code is responsible for making sure\\n    ///      that input size is power of 2 and multiple of 8 since\\n    ///      the offchain machine has a 8 byte word\\n    function addInternalInput(\\n        DiamondStorage storage ds,\\n        bytes memory input\\n    ) internal returns (bytes32) {\\n        return addInputFromSender(ds, input, address(this));\\n    }\\n\\n    /// @notice add input from a specific sender to processed by next epoch\\n    /// @notice this function is to be reserved for internal usage only\\n    /// @notice for normal inputs, call `addInput` instead\\n    /// @param ds diamond storage pointer\\n    /// @param input input to be understood by offchain machine\\n    /// @param sender input sender address\\n    /// @dev offchain code is responsible for making sure\\n    ///      that input size is power of 2 and multiple of 8 since\\n    ///      the offchain machine has a 8 byte word\\n    function addInputFromSender(\\n        DiamondStorage storage ds,\\n        bytes memory input,\\n        address sender\\n    ) internal returns (bytes32) {\\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\\n            .diamondStorage();\\n\\n        require(input.length <= ds.inputDriveSize, \\\"input len: [0,driveSize]\\\");\\n\\n        // notifyInput returns true if that input\\n        // belongs to a new epoch\\n        if (rollupsDS.notifyInput()) {\\n            swapInputBox(ds);\\n        }\\n\\n        // points to correct inputBox\\n        bytes32[] storage inputBox = ds.currentInputBox == 0\\n            ? ds.inputBox0\\n            : ds.inputBox1;\\n\\n        // get current epoch index\\n        uint256 currentEpoch = rollupsDS.getCurrentEpoch();\\n\\n        // keccak 64 bytes into 32 bytes\\n        bytes32 keccakMetadata = keccak256(\\n            abi.encode(\\n                sender,\\n                block.number,\\n                block.timestamp,\\n                currentEpoch, // epoch index\\n                inputBox.length // input index\\n            )\\n        );\\n\\n        bytes32 keccakInput = keccak256(input);\\n\\n        bytes32 inputHash = keccak256(abi.encode(keccakMetadata, keccakInput));\\n\\n        // add input to correct inbox\\n        inputBox.push(inputHash);\\n\\n        emit InputAdded(\\n            currentEpoch,\\n            inputBox.length - 1,\\n            sender,\\n            block.timestamp,\\n            input\\n        );\\n\\n        return inputHash;\\n    }\\n\\n    /// @notice called when a new input accumulation phase begins\\n    ///         swap inbox to receive inputs for upcoming epoch\\n    /// @param ds diamond storage pointer\\n    function onNewInputAccumulation(DiamondStorage storage ds) internal {\\n        swapInputBox(ds);\\n    }\\n\\n    /// @notice called when a new epoch begins, clears deprecated inputs\\n    /// @param ds diamond storage pointer\\n    function onNewEpoch(DiamondStorage storage ds) internal {\\n        // clear input box for new inputs\\n        // the current input box should be accumulating inputs\\n        // for the new epoch already. So we clear the other one.\\n        ds.currentInputBox == 0 ? delete ds.inputBox1 : delete ds.inputBox0;\\n    }\\n\\n    /// @notice changes current input box\\n    /// @param ds diamond storage pointer\\n    function swapInputBox(DiamondStorage storage ds) internal {\\n        ds.currentInputBox = (ds.currentInputBox == 0) ? 1 : 0;\\n    }\\n\\n    /// @notice input added\\n    /// @param epochNumber which epoch this input belongs to\\n    /// @param inputIndex index of the input just added\\n    /// @param sender msg.sender\\n    /// @param timestamp block.timestamp\\n    /// @param input input data\\n    event InputAdded(\\n        uint256 indexed epochNumber,\\n        uint256 indexed inputIndex,\\n        address sender,\\n        uint256 timestamp,\\n        bytes input\\n    );\\n}\\n\",\"keccak256\":\"0xbef9e65047564508f5b0c800f302d9d0b0757126968baf02e8f84a2563b2830a\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibOutput.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Output library\\npragma solidity ^0.8.0;\\n\\nlibrary LibOutput {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"Output.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        mapping(uint256 => uint256) voucherBitmask;\\n        bytes32[] epochHashes;\\n        bool lock; //reentrancy lock\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /// @notice to be called when an epoch is finalized\\n    /// @param ds diamond storage pointer\\n    /// @param epochHash hash of finalized epoch\\n    /// @dev an epoch being finalized means that its vouchers can be called\\n    function onNewEpoch(DiamondStorage storage ds, bytes32 epochHash) internal {\\n        ds.epochHashes.push(epochHash);\\n    }\\n\\n    /// @notice get number of finalized epochs\\n    /// @param ds diamond storage pointer\\n    function getNumberOfFinalizedEpochs(\\n        DiamondStorage storage ds\\n    ) internal view returns (uint256) {\\n        return ds.epochHashes.length;\\n    }\\n}\\n\",\"keccak256\":\"0xfecf86b891ef3dff302531a042fbcf25c4638cb2cb64497f3c20231cfe04ccf9\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibRollups.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Rollups library\\npragma solidity ^0.8.0;\\n\\nimport {Phase} from \\\"../interfaces/IRollups.sol\\\";\\nimport {Result} from \\\"../interfaces/IValidatorManager.sol\\\";\\n\\nimport {LibInput} from \\\"../libraries/LibInput.sol\\\";\\nimport {LibOutput} from \\\"../libraries/LibOutput.sol\\\";\\nimport {LibValidatorManager} from \\\"../libraries/LibValidatorManager.sol\\\";\\nimport {LibDisputeManager} from \\\"../libraries/LibDisputeManager.sol\\\";\\n\\nlibrary LibRollups {\\n    using LibInput for LibInput.DiamondStorage;\\n    using LibOutput for LibOutput.DiamondStorage;\\n    using LibValidatorManager for LibValidatorManager.DiamondStorage;\\n\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"Rollups.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        bytes32 templateHash; // state hash of the cartesi machine at t0\\n        uint32 inputDuration; // duration of input accumulation phase in seconds\\n        uint32 challengePeriod; // duration of challenge period in seconds\\n        uint32 inputAccumulationStart; // timestamp when current input accumulation phase started\\n        uint32 sealingEpochTimestamp; // timestamp on when a proposed epoch (claim) becomes challengeable\\n        uint32 currentPhase_int; // current phase in integer form\\n    }\\n\\n    /// @notice epoch finalized\\n    /// @param epochNumber number of the epoch being finalized\\n    /// @param epochHash claim being submitted by this epoch\\n    event FinalizeEpoch(uint256 indexed epochNumber, bytes32 epochHash);\\n\\n    /// @notice dispute resolved\\n    /// @param winner winner of dispute\\n    /// @param loser loser of dispute\\n    /// @param winningClaim initial claim of winning validator\\n    event ResolveDispute(address winner, address loser, bytes32 winningClaim);\\n\\n    /// @notice phase change\\n    /// @param newPhase new phase\\n    event PhaseChange(Phase newPhase);\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /// @notice called when new input arrives, manages the phase changes\\n    /// @param ds diamond storage pointer\\n    /// @dev can only be called by input contract\\n    function notifyInput(DiamondStorage storage ds) internal returns (bool) {\\n        Phase currentPhase = Phase(ds.currentPhase_int);\\n        uint256 inputAccumulationStart = ds.inputAccumulationStart;\\n        uint256 inputDuration = ds.inputDuration;\\n\\n        if (\\n            currentPhase == Phase.InputAccumulation &&\\n            block.timestamp > inputAccumulationStart + inputDuration\\n        ) {\\n            ds.currentPhase_int = uint32(Phase.AwaitingConsensus);\\n            emit PhaseChange(Phase.AwaitingConsensus);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /// @notice called when a dispute is resolved by the dispute manager\\n    /// @param ds diamond storage pointer\\n    /// @param winner winner of dispute\\n    /// @param loser loser of dispute\\n    /// @param winningClaim initial claim of winning validator\\n    function resolveDispute(\\n        DiamondStorage storage ds,\\n        address payable winner,\\n        address payable loser,\\n        bytes32 winningClaim\\n    ) internal {\\n        Result result;\\n        bytes32[2] memory claims;\\n        address payable[2] memory claimers;\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n\\n        (result, claims, claimers) = validatorManagerDS.onDisputeEnd(\\n            winner,\\n            loser,\\n            winningClaim\\n        );\\n\\n        // restart challenge period\\n        ds.sealingEpochTimestamp = uint32(block.timestamp);\\n\\n        emit ResolveDispute(winner, loser, winningClaim);\\n        resolveValidatorResult(ds, result, claims, claimers);\\n    }\\n\\n    /// @notice resolve results returned by validator manager\\n    /// @param ds diamond storage pointer\\n    /// @param result result from claim or dispute operation\\n    /// @param claims array of claims in case of new conflict\\n    /// @param claimers array of claimers in case of new conflict\\n    function resolveValidatorResult(\\n        DiamondStorage storage ds,\\n        Result result,\\n        bytes32[2] memory claims,\\n        address payable[2] memory claimers\\n    ) internal {\\n        if (result == Result.NoConflict) {\\n            Phase currentPhase = Phase(ds.currentPhase_int);\\n            if (currentPhase != Phase.AwaitingConsensus) {\\n                ds.currentPhase_int = uint32(Phase.AwaitingConsensus);\\n                emit PhaseChange(Phase.AwaitingConsensus);\\n            }\\n        } else if (result == Result.Consensus) {\\n            startNewEpoch(ds);\\n        } else {\\n            // for the case when result == Result.Conflict\\n            Phase currentPhase = Phase(ds.currentPhase_int);\\n            if (currentPhase != Phase.AwaitingDispute) {\\n                ds.currentPhase_int = uint32(Phase.AwaitingDispute);\\n                emit PhaseChange(Phase.AwaitingDispute);\\n            }\\n            LibDisputeManager.initiateDispute(claims, claimers);\\n        }\\n    }\\n\\n    /// @notice starts new epoch\\n    /// @param ds diamond storage pointer\\n    function startNewEpoch(DiamondStorage storage ds) internal {\\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\\n        LibOutput.DiamondStorage storage outputDS = LibOutput.diamondStorage();\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n\\n        // reset input accumulation start and deactivate challenge period start\\n        ds.currentPhase_int = uint32(Phase.InputAccumulation);\\n        emit PhaseChange(Phase.InputAccumulation);\\n        ds.inputAccumulationStart = uint32(block.timestamp);\\n        ds.sealingEpochTimestamp = type(uint32).max;\\n\\n        bytes32 finalClaim = validatorManagerDS.onNewEpoch();\\n\\n        // emit event before finalized epoch is added to the Output storage\\n        emit FinalizeEpoch(outputDS.getNumberOfFinalizedEpochs(), finalClaim);\\n\\n        outputDS.onNewEpoch(finalClaim);\\n        inputDS.onNewEpoch();\\n    }\\n\\n    /// @notice returns index of current (accumulating) epoch\\n    /// @param ds diamond storage pointer\\n    /// @return index of current epoch\\n    /// @dev if phase is input accumulation, then the epoch number is length\\n    ///      of finalized epochs array, else there are two non finalized epochs,\\n    ///      one awaiting consensus/dispute and another accumulating input\\n    function getCurrentEpoch(\\n        DiamondStorage storage ds\\n    ) internal view returns (uint256) {\\n        LibOutput.DiamondStorage storage outputDS = LibOutput.diamondStorage();\\n\\n        uint256 finalizedEpochs = outputDS.getNumberOfFinalizedEpochs();\\n\\n        Phase currentPhase = Phase(ds.currentPhase_int);\\n\\n        return\\n            currentPhase == Phase.InputAccumulation\\n                ? finalizedEpochs\\n                : finalizedEpochs + 1;\\n    }\\n}\\n\",\"keccak256\":\"0x6455b49596bcc13c3d87869f6795fb747f38efe784f8fc504572f8fb16c00f30\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibValidatorManager.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Validator Manager library\\npragma solidity ^0.8.0;\\n\\nimport {Result} from \\\"../interfaces/IValidatorManager.sol\\\";\\n\\nimport {LibClaimsMask, ClaimsMask} from \\\"../libraries/LibClaimsMask.sol\\\";\\nimport {LibFeeManager} from \\\"../libraries/LibFeeManager.sol\\\";\\n\\nlibrary LibValidatorManager {\\n    using LibClaimsMask for ClaimsMask;\\n    using LibFeeManager for LibFeeManager.DiamondStorage;\\n\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"ValidatorManager.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        bytes32 currentClaim; // current claim - first claim of this epoch\\n        address payable[] validators; // up to 8 validators\\n        uint256 maxNumValidators; // the maximum number of validators, set in the constructor\\n        // A bit set used for up to 8 validators.\\n        // The first 8 bits are used to indicate whom supports the current claim\\n        // The second 8 bits are used to indicate those should have claimed in order to reach consensus\\n        // The following every 30 bits are used to indicate the number of total claims each validator has made\\n        // | agreement mask | consensus mask | #claims_validator7 | #claims_validator6 | ... | #claims_validator0 |\\n        // |     8 bits     |     8 bits     |      30 bits       |      30 bits       | ... |      30 bits       |\\n        ClaimsMask claimsMask;\\n    }\\n\\n    /// @notice emitted on Claim received\\n    event ClaimReceived(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on Dispute end\\n    event DisputeEnded(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on new Epoch\\n    event NewEpoch(bytes32 claim);\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /// @notice called when a dispute ends in rollups\\n    /// @param ds diamond storage pointer\\n    /// @param winner address of dispute winner\\n    /// @param loser address of dispute loser\\n    /// @param winningClaim the winnning claim\\n    /// @return result of dispute being finished\\n    function onDisputeEnd(\\n        DiamondStorage storage ds,\\n        address payable winner,\\n        address payable loser,\\n        bytes32 winningClaim\\n    ) internal returns (Result, bytes32[2] memory, address payable[2] memory) {\\n        removeValidator(ds, loser);\\n\\n        if (winningClaim == ds.currentClaim) {\\n            // first claim stood, dont need to update the bitmask\\n            return\\n                isConsensus(ds)\\n                    ? emitDisputeEndedAndReturn(\\n                        Result.Consensus,\\n                        [winningClaim, bytes32(0)],\\n                        [winner, payable(0)]\\n                    )\\n                    : emitDisputeEndedAndReturn(\\n                        Result.NoConflict,\\n                        [winningClaim, bytes32(0)],\\n                        [winner, payable(0)]\\n                    );\\n        }\\n\\n        // if first claim lost, and other validators have agreed with it\\n        // there is a new dispute to be played\\n        if (ds.claimsMask.getAgreementMask() != 0) {\\n            return\\n                emitDisputeEndedAndReturn(\\n                    Result.Conflict,\\n                    [ds.currentClaim, winningClaim],\\n                    [getClaimerOfCurrentClaim(ds), winner]\\n                );\\n        }\\n        // else there are no valdiators that agree with losing claim\\n        // we can update current claim and check for consensus in case\\n        // the winner is the only validator left\\n        ds.currentClaim = winningClaim;\\n        updateClaimAgreementMask(ds, winner);\\n        return\\n            isConsensus(ds)\\n                ? emitDisputeEndedAndReturn(\\n                    Result.Consensus,\\n                    [winningClaim, bytes32(0)],\\n                    [winner, payable(0)]\\n                )\\n                : emitDisputeEndedAndReturn(\\n                    Result.NoConflict,\\n                    [winningClaim, bytes32(0)],\\n                    [winner, payable(0)]\\n                );\\n    }\\n\\n    /// @notice called when a new epoch starts\\n    /// @param ds diamond storage pointer\\n    /// @return current claim\\n    function onNewEpoch(DiamondStorage storage ds) internal returns (bytes32) {\\n        // reward validators who has made the correct claim by increasing their #claims\\n        claimFinalizedIncreaseCounts(ds);\\n\\n        bytes32 tmpClaim = ds.currentClaim;\\n\\n        // clear current claim\\n        ds.currentClaim = bytes32(0);\\n        // clear validator agreement bit mask\\n        ds.claimsMask = ds.claimsMask.clearAgreementMask();\\n\\n        emit NewEpoch(tmpClaim);\\n        return tmpClaim;\\n    }\\n\\n    /// @notice called when a claim is received by rollups\\n    /// @param ds diamond storage pointer\\n    /// @param sender address of sender of that claim\\n    /// @param claim claim received by rollups\\n    /// @return result of claim, Consensus | NoConflict | Conflict\\n    /// @return [currentClaim, conflicting claim] if there is Conflict\\n    ///         [currentClaim, bytes32(0)] if there is Consensus or NoConflcit\\n    /// @return [claimer1, claimer2] if there is  Conflcit\\n    ///         [claimer1, address(0)] if there is Consensus or NoConflcit\\n    function onClaim(\\n        DiamondStorage storage ds,\\n        address payable sender,\\n        bytes32 claim\\n    ) internal returns (Result, bytes32[2] memory, address payable[2] memory) {\\n        require(claim != bytes32(0), \\\"empty claim\\\");\\n        require(isValidator(ds, sender), \\\"sender not allowed\\\");\\n\\n        // require the validator hasn't claimed in the same epoch before\\n        uint256 index = getValidatorIndex(ds, sender);\\n        require(\\n            !ds.claimsMask.alreadyClaimed(index),\\n            \\\"sender had claimed in this epoch before\\\"\\n        );\\n\\n        // cant return because a single claim might mean consensus\\n        if (ds.currentClaim == bytes32(0)) {\\n            ds.currentClaim = claim;\\n        } else if (claim != ds.currentClaim) {\\n            return\\n                emitClaimReceivedAndReturn(\\n                    Result.Conflict,\\n                    [ds.currentClaim, claim],\\n                    [getClaimerOfCurrentClaim(ds), sender]\\n                );\\n        }\\n        updateClaimAgreementMask(ds, sender);\\n\\n        return\\n            isConsensus(ds)\\n                ? emitClaimReceivedAndReturn(\\n                    Result.Consensus,\\n                    [claim, bytes32(0)],\\n                    [sender, payable(0)]\\n                )\\n                : emitClaimReceivedAndReturn(\\n                    Result.NoConflict,\\n                    [claim, bytes32(0)],\\n                    [sender, payable(0)]\\n                );\\n    }\\n\\n    /// @notice emits dispute ended event and then return\\n    /// @param result to be emitted and returned\\n    /// @param claims to be emitted and returned\\n    /// @param validators to be emitted and returned\\n    /// @dev this function existis to make code more clear/concise\\n    function emitDisputeEndedAndReturn(\\n        Result result,\\n        bytes32[2] memory claims,\\n        address payable[2] memory validators\\n    ) internal returns (Result, bytes32[2] memory, address payable[2] memory) {\\n        emit DisputeEnded(result, claims, validators);\\n        return (result, claims, validators);\\n    }\\n\\n    /// @notice emits claim received event and then return\\n    /// @param result to be emitted and returned\\n    /// @param claims to be emitted and returned\\n    /// @param validators to be emitted and returned\\n    /// @dev this function existis to make code more clear/concise\\n    function emitClaimReceivedAndReturn(\\n        Result result,\\n        bytes32[2] memory claims,\\n        address payable[2] memory validators\\n    ) internal returns (Result, bytes32[2] memory, address payable[2] memory) {\\n        emit ClaimReceived(result, claims, validators);\\n        return (result, claims, validators);\\n    }\\n\\n    /// @notice only call this function when a claim has been finalized\\n    ///         Either a consensus has been reached or challenge period has past\\n    /// @param ds pointer to diamond storage\\n    function claimFinalizedIncreaseCounts(DiamondStorage storage ds) internal {\\n        uint256 agreementMask = ds.claimsMask.getAgreementMask();\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            // if a validator agrees with the current claim\\n            if ((agreementMask & (1 << i)) != 0) {\\n                // increase #claims by 1\\n                ds.claimsMask = ds.claimsMask.increaseNumClaims(i, 1);\\n            }\\n        }\\n    }\\n\\n    /// @notice removes a validator\\n    /// @param ds diamond storage pointer\\n    /// @param validator address of validator to be removed\\n    function removeValidator(\\n        DiamondStorage storage ds,\\n        address validator\\n    ) internal {\\n        LibFeeManager.DiamondStorage storage feeManagerDS = LibFeeManager\\n            .diamondStorage();\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (validator == ds.validators[i]) {\\n                // put address(0) in validators position\\n                ds.validators[i] = payable(0);\\n                // remove the validator from ValidatorManager's claimsMask\\n                ds.claimsMask = ds.claimsMask.removeValidator(i);\\n                // remove the validator from FeeManager's claimsMask (#redeems)\\n                feeManagerDS.removeValidator(i);\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @notice check if consensus has been reached\\n    /// @param ds pointer to diamond storage\\n    function isConsensus(\\n        DiamondStorage storage ds\\n    ) internal view returns (bool) {\\n        ClaimsMask claimsMask = ds.claimsMask;\\n        return\\n            claimsMask.getAgreementMask() == claimsMask.getConsensusGoalMask();\\n    }\\n\\n    /// @notice get one of the validators that agreed with current claim\\n    /// @param ds diamond storage pointer\\n    /// @return validator that agreed with current claim\\n    function getClaimerOfCurrentClaim(\\n        DiamondStorage storage ds\\n    ) internal view returns (address payable) {\\n        // TODO: we are always getting the first validator\\n        // on the array that agrees with the current claim to enter a dispute\\n        // should this be random?\\n        uint256 agreementMask = ds.claimsMask.getAgreementMask();\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (agreementMask & (1 << i) != 0) {\\n                return ds.validators[i];\\n            }\\n        }\\n        revert(\\\"Agreeing validator not found\\\");\\n    }\\n\\n    /// @notice updates mask of validators that agreed with current claim\\n    /// @param ds diamond storage pointer\\n    /// @param sender address of validator that will be included in mask\\n    function updateClaimAgreementMask(\\n        DiamondStorage storage ds,\\n        address payable sender\\n    ) internal {\\n        uint256 validatorIndex = getValidatorIndex(ds, sender);\\n        ds.claimsMask = ds.claimsMask.setAgreementMask(validatorIndex);\\n    }\\n\\n    /// @notice check if the sender is a validator\\n    /// @param ds pointer to diamond storage\\n    /// @param sender sender address\\n    function isValidator(\\n        DiamondStorage storage ds,\\n        address sender\\n    ) internal view returns (bool) {\\n        require(sender != address(0), \\\"address 0\\\");\\n\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (sender == ds.validators[i]) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice find the validator and return the index or revert\\n    /// @param ds pointer to diamond storage\\n    /// @param sender validator address\\n    /// @return validator index or revert\\n    function getValidatorIndex(\\n        DiamondStorage storage ds,\\n        address sender\\n    ) internal view returns (uint256) {\\n        require(sender != address(0), \\\"address 0\\\");\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (sender == ds.validators[i]) return i;\\n        }\\n        revert(\\\"validator not found\\\");\\n    }\\n\\n    /// @notice get number of claims the sender has made\\n    /// @param ds pointer to diamond storage\\n    /// @param _sender validator address\\n    /// @return #claims\\n    function getNumberOfClaimsByAddress(\\n        DiamondStorage storage ds,\\n        address payable _sender\\n    ) internal view returns (uint256) {\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (_sender == ds.validators[i]) {\\n                return getNumberOfClaimsByIndex(ds, i);\\n            }\\n        }\\n        // if validator not found\\n        return 0;\\n    }\\n\\n    /// @notice get number of claims by the index in the validator set\\n    /// @param ds pointer to diamond storage\\n    /// @param index the index in validator set\\n    /// @return #claims\\n    function getNumberOfClaimsByIndex(\\n        DiamondStorage storage ds,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        return ds.claimsMask.getNumClaims(index);\\n    }\\n\\n    /// @notice get the maximum number of validators defined in validator manager\\n    /// @param ds pointer to diamond storage\\n    /// @return the maximum number of validators\\n    function getMaxNumValidators(\\n        DiamondStorage storage ds\\n    ) internal view returns (uint256) {\\n        return ds.maxNumValidators;\\n    }\\n}\\n\",\"keccak256\":\"0x14acffee6376e0ea2ca258c4ff60e9b29c162b2bcd11f2d5c3ad50698aebff2c\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50611051806100206000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c806325ce6e95146100515780638c35926314610079578063bc197c811461008c578063f23a6e61146100b8575b600080fd5b61006461005f366004610842565b6100cb565b60405190151581526020015b60405180910390f35b610064610087366004610842565b6101e4565b61009f61009a3660046108e1565b6102e1565b6040516001600160e01b03199091168152602001610070565b61009f6100c63660046109a0565b6103c9565b600033301461010f5760405162461bcd60e51b815260206004820152600b60248201526a37b7363c9034ba39b2b63360a91b60448201526064015b60405180910390fd5b60008080808061012187890189610ad3565b604051637921219560e11b81529499509297509095509350915085906001600160a01b0382169063f242432a906101649030908990899089908990600401610b96565b600060405180830381600087803b15801561017e57600080fd5b505af1158015610192573d6000803e3d6000fd5b505050507f73801e57e11a7b77c97a2f5fbe3561cd83e96b5976d95bd22902367de0ca9ce686868686866040516101cd959493929190610b96565b60405180910390a150600198975050505050505050565b60003330146102235760405162461bcd60e51b815260206004820152600b60248201526a37b7363c9034ba39b2b63360a91b6044820152606401610106565b60008080808061023587890189610c50565b604051631759616b60e11b81529499509297509095509350915085906001600160a01b03821690632eb2c2d6906102789030908990899089908990600401610d2c565b600060405180830381600087803b15801561029257600080fd5b505af11580156102a6573d6000803e3d6000fd5b505050507f7cd272a48dca17a8f404682ce51ba18d2ec2ee1abf53d387dbbf84c86a482cee86868686866040516101cd959493929190610d2c565b6040516000907f943d5d24442f02461445e15c5d7d4a4ef0acb0d32c5d6f6af37a6882249912ff903390839061034d907f478494c6565083f3ed97b6c6d8247fde8de3bf8b5c905a40aba9c9dd613a7a4e9084908f908f908f908f908f908f908f908f90602001610de9565b60408051601f19818403018152919052905061036983826104a7565b507f9413f1bebf2c3d0b8f8b36f93bcab5e7b487c554a27383a244918d365dd958a2828d8d8d8d8d8d8d8d6040516103a999989796959493929190610e5d565b60405180910390a15063bc197c8160e01b9b9a5050505050505050505050565b6040516000907f943d5d24442f02461445e15c5d7d4a4ef0acb0d32c5d6f6af37a6882249912ff9033908390610431907f478494c6565083f3ed97b6c6d8247fde8de3bf8b5c905a40aba9c9dd613a7a4e9084908d908d908d908d908d908d90602001610eca565b60408051601f19818403018152919052905061044d83826104a7565b507f0e2691993fdd84440b8e3e2fef1888408bcf77bdff97325796c776218fc14540828b8b8b8b8b8b6040516104899796959493929190610f21565b60405180910390a15063f23a6e6160e01b9998505050505050505050565b60006104b48383306104bb565b9392505050565b600283015482516000917fd32d7f90491bee81172a406b65f3270d810392fe53bb0379dde8bdd4e624189c9111156105355760405162461bcd60e51b815260206004820152601860248201527f696e707574206c656e3a205b302c647269766553697a655d00000000000000006044820152606401610106565b61053e81610660565b1561054c5761054c85610738565b600085600301546000146105635785600101610565565b855b9050600061057283610757565b8254604080516001600160a01b03891660208083019190915243828401524260608301526080820185905260a08083018590528351808403909101815260c0830184528051908201208b518c83012060e084018290526101008085018290528551808603909101815261012090940190945282519282019290922060018086018955600089815292909220909401849055865494955090939192916106179190610f87565b847fa15a0da5519c084484141aaa73e525cee96062f5decc97e070f0c4da27738bc78a428d60405161064b93929190610f9e565b60405180910390a39998505050505050505050565b60018101546000908190600160801b900463ffffffff16600281111561068857610688610fc5565b600184015490915063ffffffff6801000000000000000082048116911660008360028111156106b9576106b9610fc5565b1480156106ce57506106cb8183610fdb565b42115b1561072d576001858101805463ffffffff60801b1916600160801b1790556040517fed606d544c2202d032d2626c390923e6f260ca5d89625bba0cfe70d2bdda4e8f9161071a91610ff3565b60405180910390a1506001949350505050565b506000949350505050565b60038101541561074957600061074c565b60015b60ff16600390910155565b7f0635ad75fae4d4e8d896461a635d23700076a1c3fd8da26276f18cb1c09ea5675460018201546000917f0635ad75fae4d4e8d896461a635d23700076a1c3fd8da26276f18cb1c09ea566918390600160801b900463ffffffff1660028111156107c3576107c3610fc5565b905060008160028111156107d9576107d9610fc5565b146107ee576107e9826001610fdb565b6107f0565b815b95945050505050565b60008083601f84011261080b57600080fd5b50813567ffffffffffffffff81111561082357600080fd5b60208301915083602082850101111561083b57600080fd5b9250929050565b6000806020838503121561085557600080fd5b823567ffffffffffffffff81111561086c57600080fd5b610878858286016107f9565b90969095509350505050565b6001600160a01b038116811461089957600080fd5b50565b60008083601f8401126108ae57600080fd5b50813567ffffffffffffffff8111156108c657600080fd5b6020830191508360208260051b850101111561083b57600080fd5b60008060008060008060008060a0898b0312156108fd57600080fd5b883561090881610884565b9750602089013561091881610884565b9650604089013567ffffffffffffffff8082111561093557600080fd5b6109418c838d0161089c565b909850965060608b013591508082111561095a57600080fd5b6109668c838d0161089c565b909650945060808b013591508082111561097f57600080fd5b5061098c8b828c016107f9565b999c989b5096995094979396929594505050565b60008060008060008060a087890312156109b957600080fd5b86356109c481610884565b955060208701356109d481610884565b94506040870135935060608701359250608087013567ffffffffffffffff8111156109fe57600080fd5b610a0a89828a016107f9565b979a9699509497509295939492505050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715610a5b57610a5b610a1c565b604052919050565b600082601f830112610a7457600080fd5b813567ffffffffffffffff811115610a8e57610a8e610a1c565b610aa1601f8201601f1916602001610a32565b818152846020838601011115610ab657600080fd5b816020850160208301376000918101602001919091529392505050565b600080600080600060a08688031215610aeb57600080fd5b8535610af681610884565b94506020860135610b0681610884565b93506040860135925060608601359150608086013567ffffffffffffffff811115610b3057600080fd5b610b3c88828901610a63565b9150509295509295909350565b6000815180845260005b81811015610b6f57602081850181015186830182015201610b53565b81811115610b81576000602083870101525b50601f01601f19169290920160200192915050565b6001600160a01b03868116825285166020820152604081018490526060810183905260a060808201819052600090610bd090830184610b49565b979650505050505050565b600082601f830112610bec57600080fd5b8135602067ffffffffffffffff821115610c0857610c08610a1c565b8160051b610c17828201610a32565b9283528481018201928281019087851115610c3157600080fd5b83870192505b84831015610bd057823582529183019190830190610c37565b600080600080600060a08688031215610c6857600080fd5b8535610c7381610884565b94506020860135610c8381610884565b9350604086013567ffffffffffffffff80821115610ca057600080fd5b610cac89838a01610bdb565b94506060880135915080821115610cc257600080fd5b610cce89838a01610bdb565b93506080880135915080821115610ce457600080fd5b50610b3c88828901610a63565b600081518084526020808501945080840160005b83811015610d2157815187529582019590820190600101610d05565b509495945050505050565b6001600160a01b0386811682528516602082015260a060408201819052600090610d5890830186610cf1565b8281036060840152610d6a8186610cf1565b90508281036080840152610d7e8185610b49565b98975050505050505050565b81835260006001600160fb1b03831115610da357600080fd5b8260051b8083602087013760009401602001938452509192915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b8a81526001600160a01b038a8116602083015289811660408301528816606082015260e060808201819052600090610e24908301888a610d8a565b82810360a0840152610e37818789610d8a565b905082810360c0840152610e4c818587610dc0565b9d9c50505050505050505050505050565b6001600160a01b038a8116825289811660208301528816604082015260c060608201819052600090610e92908301888a610d8a565b8281036080840152610ea5818789610d8a565b905082810360a0840152610eba818587610dc0565b9c9b505050505050505050505050565b8881526001600160a01b0388811660208301528781166040830152861660608201526080810185905260a0810184905260e060c08201819052600090610f139083018486610dc0565b9a9950505050505050505050565b6001600160a01b038881168252878116602083015286166040820152606081018590526080810184905260c060a08201819052600090610f649083018486610dc0565b9998505050505050505050565b634e487b7160e01b600052601160045260246000fd5b600082821015610f9957610f99610f71565b500390565b60018060a01b03841681528260208201526060604082015260006107f06060830184610b49565b634e487b7160e01b600052602160045260246000fd5b60008219821115610fee57610fee610f71565b500190565b602081016003831061101557634e487b7160e01b600052602160045260246000fd5b9190529056fea2646970667358221220e063159814f331bcc2f211faeb3c6caf6a8ff0f6621cb1d075bdf94e9ad844e964736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c806325ce6e95146100515780638c35926314610079578063bc197c811461008c578063f23a6e61146100b8575b600080fd5b61006461005f366004610842565b6100cb565b60405190151581526020015b60405180910390f35b610064610087366004610842565b6101e4565b61009f61009a3660046108e1565b6102e1565b6040516001600160e01b03199091168152602001610070565b61009f6100c63660046109a0565b6103c9565b600033301461010f5760405162461bcd60e51b815260206004820152600b60248201526a37b7363c9034ba39b2b63360a91b60448201526064015b60405180910390fd5b60008080808061012187890189610ad3565b604051637921219560e11b81529499509297509095509350915085906001600160a01b0382169063f242432a906101649030908990899089908990600401610b96565b600060405180830381600087803b15801561017e57600080fd5b505af1158015610192573d6000803e3d6000fd5b505050507f73801e57e11a7b77c97a2f5fbe3561cd83e96b5976d95bd22902367de0ca9ce686868686866040516101cd959493929190610b96565b60405180910390a150600198975050505050505050565b60003330146102235760405162461bcd60e51b815260206004820152600b60248201526a37b7363c9034ba39b2b63360a91b6044820152606401610106565b60008080808061023587890189610c50565b604051631759616b60e11b81529499509297509095509350915085906001600160a01b03821690632eb2c2d6906102789030908990899089908990600401610d2c565b600060405180830381600087803b15801561029257600080fd5b505af11580156102a6573d6000803e3d6000fd5b505050507f7cd272a48dca17a8f404682ce51ba18d2ec2ee1abf53d387dbbf84c86a482cee86868686866040516101cd959493929190610d2c565b6040516000907f943d5d24442f02461445e15c5d7d4a4ef0acb0d32c5d6f6af37a6882249912ff903390839061034d907f478494c6565083f3ed97b6c6d8247fde8de3bf8b5c905a40aba9c9dd613a7a4e9084908f908f908f908f908f908f908f908f90602001610de9565b60408051601f19818403018152919052905061036983826104a7565b507f9413f1bebf2c3d0b8f8b36f93bcab5e7b487c554a27383a244918d365dd958a2828d8d8d8d8d8d8d8d6040516103a999989796959493929190610e5d565b60405180910390a15063bc197c8160e01b9b9a5050505050505050505050565b6040516000907f943d5d24442f02461445e15c5d7d4a4ef0acb0d32c5d6f6af37a6882249912ff9033908390610431907f478494c6565083f3ed97b6c6d8247fde8de3bf8b5c905a40aba9c9dd613a7a4e9084908d908d908d908d908d908d90602001610eca565b60408051601f19818403018152919052905061044d83826104a7565b507f0e2691993fdd84440b8e3e2fef1888408bcf77bdff97325796c776218fc14540828b8b8b8b8b8b6040516104899796959493929190610f21565b60405180910390a15063f23a6e6160e01b9998505050505050505050565b60006104b48383306104bb565b9392505050565b600283015482516000917fd32d7f90491bee81172a406b65f3270d810392fe53bb0379dde8bdd4e624189c9111156105355760405162461bcd60e51b815260206004820152601860248201527f696e707574206c656e3a205b302c647269766553697a655d00000000000000006044820152606401610106565b61053e81610660565b1561054c5761054c85610738565b600085600301546000146105635785600101610565565b855b9050600061057283610757565b8254604080516001600160a01b03891660208083019190915243828401524260608301526080820185905260a08083018590528351808403909101815260c0830184528051908201208b518c83012060e084018290526101008085018290528551808603909101815261012090940190945282519282019290922060018086018955600089815292909220909401849055865494955090939192916106179190610f87565b847fa15a0da5519c084484141aaa73e525cee96062f5decc97e070f0c4da27738bc78a428d60405161064b93929190610f9e565b60405180910390a39998505050505050505050565b60018101546000908190600160801b900463ffffffff16600281111561068857610688610fc5565b600184015490915063ffffffff6801000000000000000082048116911660008360028111156106b9576106b9610fc5565b1480156106ce57506106cb8183610fdb565b42115b1561072d576001858101805463ffffffff60801b1916600160801b1790556040517fed606d544c2202d032d2626c390923e6f260ca5d89625bba0cfe70d2bdda4e8f9161071a91610ff3565b60405180910390a1506001949350505050565b506000949350505050565b60038101541561074957600061074c565b60015b60ff16600390910155565b7f0635ad75fae4d4e8d896461a635d23700076a1c3fd8da26276f18cb1c09ea5675460018201546000917f0635ad75fae4d4e8d896461a635d23700076a1c3fd8da26276f18cb1c09ea566918390600160801b900463ffffffff1660028111156107c3576107c3610fc5565b905060008160028111156107d9576107d9610fc5565b146107ee576107e9826001610fdb565b6107f0565b815b95945050505050565b60008083601f84011261080b57600080fd5b50813567ffffffffffffffff81111561082357600080fd5b60208301915083602082850101111561083b57600080fd5b9250929050565b6000806020838503121561085557600080fd5b823567ffffffffffffffff81111561086c57600080fd5b610878858286016107f9565b90969095509350505050565b6001600160a01b038116811461089957600080fd5b50565b60008083601f8401126108ae57600080fd5b50813567ffffffffffffffff8111156108c657600080fd5b6020830191508360208260051b850101111561083b57600080fd5b60008060008060008060008060a0898b0312156108fd57600080fd5b883561090881610884565b9750602089013561091881610884565b9650604089013567ffffffffffffffff8082111561093557600080fd5b6109418c838d0161089c565b909850965060608b013591508082111561095a57600080fd5b6109668c838d0161089c565b909650945060808b013591508082111561097f57600080fd5b5061098c8b828c016107f9565b999c989b5096995094979396929594505050565b60008060008060008060a087890312156109b957600080fd5b86356109c481610884565b955060208701356109d481610884565b94506040870135935060608701359250608087013567ffffffffffffffff8111156109fe57600080fd5b610a0a89828a016107f9565b979a9699509497509295939492505050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715610a5b57610a5b610a1c565b604052919050565b600082601f830112610a7457600080fd5b813567ffffffffffffffff811115610a8e57610a8e610a1c565b610aa1601f8201601f1916602001610a32565b818152846020838601011115610ab657600080fd5b816020850160208301376000918101602001919091529392505050565b600080600080600060a08688031215610aeb57600080fd5b8535610af681610884565b94506020860135610b0681610884565b93506040860135925060608601359150608086013567ffffffffffffffff811115610b3057600080fd5b610b3c88828901610a63565b9150509295509295909350565b6000815180845260005b81811015610b6f57602081850181015186830182015201610b53565b81811115610b81576000602083870101525b50601f01601f19169290920160200192915050565b6001600160a01b03868116825285166020820152604081018490526060810183905260a060808201819052600090610bd090830184610b49565b979650505050505050565b600082601f830112610bec57600080fd5b8135602067ffffffffffffffff821115610c0857610c08610a1c565b8160051b610c17828201610a32565b9283528481018201928281019087851115610c3157600080fd5b83870192505b84831015610bd057823582529183019190830190610c37565b600080600080600060a08688031215610c6857600080fd5b8535610c7381610884565b94506020860135610c8381610884565b9350604086013567ffffffffffffffff80821115610ca057600080fd5b610cac89838a01610bdb565b94506060880135915080821115610cc257600080fd5b610cce89838a01610bdb565b93506080880135915080821115610ce457600080fd5b50610b3c88828901610a63565b600081518084526020808501945080840160005b83811015610d2157815187529582019590820190600101610d05565b509495945050505050565b6001600160a01b0386811682528516602082015260a060408201819052600090610d5890830186610cf1565b8281036060840152610d6a8186610cf1565b90508281036080840152610d7e8185610b49565b98975050505050505050565b81835260006001600160fb1b03831115610da357600080fd5b8260051b8083602087013760009401602001938452509192915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b8a81526001600160a01b038a8116602083015289811660408301528816606082015260e060808201819052600090610e24908301888a610d8a565b82810360a0840152610e37818789610d8a565b905082810360c0840152610e4c818587610dc0565b9d9c50505050505050505050505050565b6001600160a01b038a8116825289811660208301528816604082015260c060608201819052600090610e92908301888a610d8a565b8281036080840152610ea5818789610d8a565b905082810360a0840152610eba818587610dc0565b9c9b505050505050505050505050565b8881526001600160a01b0388811660208301528781166040830152861660608201526080810185905260a0810184905260e060c08201819052600090610f139083018486610dc0565b9a9950505050505050505050565b6001600160a01b038881168252878116602083015286166040820152606081018590526080810184905260c060a08201819052600090610f649083018486610dc0565b9998505050505050505050565b634e487b7160e01b600052601160045260246000fd5b600082821015610f9957610f99610f71565b500390565b60018060a01b03841681528260208201526060604082015260006107f06060830184610b49565b634e487b7160e01b600052602160045260246000fd5b60008219821115610fee57610fee610f71565b500190565b602081016003831061101557634e487b7160e01b600052602160045260246000fd5b9190529056fea2646970667358221220e063159814f331bcc2f211faeb3c6caf6a8ff0f6621cb1d075bdf94e9ad844e964736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "erc1155BatchWithdrawal(bytes)": {
        "details": "can only be called by the Rollups contract",
        "params": {
          "_data": "data with withdrawal information"
        }
      },
      "erc1155Withdrawal(bytes)": {
        "details": "can only be called by the Rollups contract",
        "params": {
          "_data": "data with withdrawal information"
        }
      },
      "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": {
        "details": "The ERC1155 smart contract calls this function on the recipient  after a `transfer`. This function MAY throw to revert and reject the  transfer. Return of other than the magic value MUST result in the  transaction being reverted.  Note: the contract address is always the message sender.",
        "params": {
          "_data": "Additional data to be interpreted by L2",
          "_from": "The address which previously owned the tokens",
          "_operator": "The address which called `safeBatchTransferFrom` function",
          "_tokenAmounts": "The token amounts which are being transferred",
          "_tokenIds": "The token identifiers which are being transferred"
        },
        "returns": {
          "_0": "this function selector unless throwing"
        }
      },
      "onERC1155Received(address,address,uint256,uint256,bytes)": {
        "details": "The ERC1155 smart contract calls this function on the recipient  after a `transfer`. This function MAY throw to revert and reject the  transfer. Return of other than the magic value MUST result in the  transaction being reverted.  Note: the contract address is always the message sender.",
        "params": {
          "_data": "Additional data to be interpreted by L2",
          "_from": "The address which previously owned the token",
          "_operator": "The address which called `safeTransferFrom` function",
          "_tokenAmount": "The token amount which is being transferred",
          "_tokenId": "The token identifier which is being transferred"
        },
        "returns": {
          "_0": "this function selector unless throwing"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "ERC1155BatchReceived(address,address,address,uint256[],uint256[],bytes)": {
        "notice": "emitted on a call to `onERC1155BatchReceived`"
      },
      "ERC1155BatchWithdrawn(address,address,uint256[],uint256[],bytes)": {
        "notice": "emitted on ERC1155 batch withdrawal"
      },
      "ERC1155Received(address,address,address,uint256,uint256,bytes)": {
        "notice": "emitted on a call to `onERC1155Received`"
      },
      "ERC1155Withdrawn(address,address,uint256,uint256,bytes)": {
        "notice": "emitted on ERC1155 withdrawal"
      }
    },
    "kind": "user",
    "methods": {
      "erc1155BatchWithdrawal(bytes)": {
        "notice": "withdraw a batch of ERC1155 tokens from the portal"
      },
      "erc1155Withdrawal(bytes)": {
        "notice": "withdraw an ERC1155 token from the portal"
      },
      "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": {
        "notice": "Handle the receipt of a batch of ERC1155 tokens"
      },
      "onERC1155Received(address,address,uint256,uint256,bytes)": {
        "notice": "Handle the receipt of an ERC1155 token"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}